# =====================================================
# NGINX REVERSE PROXY - GeoSegBar API
# =====================================================
# Objetivo: proteger o Tomcat de conexões lentas do browser.
# nginx recebe o body completo do cliente (buffering),
# depois repassa ao Tomcat quase instantaneamente via
# rede interna Docker. Isso elimina EOFException e libera
# threads do Tomcat rapidamente.
# =====================================================

upstream backend {
    server ${UPSTREAM_SERVER};
    keepalive 32;
}

server {
    listen 80;
    server_name _;

    # ================================================
    # PERFORMANCE DO KERNEL / TCP
    # ================================================
    # sendfile: transfere dados diretamente no kernel (zero-copy)
    sendfile on;
    # tcp_nopush: envia headers + body juntos num único pacote
    tcp_nopush on;
    # tcp_nodelay: desativa Nagle algorithm para respostas rápidas
    tcp_nodelay on;

    # ================================================
    # UPLOAD / REQUEST BODY
    # ================================================
    # Tamanho máximo do corpo da requisição (deve bater com spring.servlet.multipart.max-request-size)
    client_max_body_size 512m;

    # proxy_request_buffering ON (default) = nginx recebe TODO o body
    # do cliente antes de encaminhar ao Tomcat.
    # Isso é ESSENCIAL para proteger threads do Tomcat.
    # Com buffering ON:
    #   - Browser envia 51MB em 5 min → nginx recebe tudo (event-driven, sem thread bloqueada)
    #   - nginx encaminha 51MB ao Tomcat via rede Docker → ~1 segundo
    #   - Thread Tomcat ocupada apenas ~3s (receber + enviar S3)
    # Sem buffering:
    #   - Thread Tomcat bloqueada 5 minutos inteiros
    proxy_request_buffering on;

    # Tempo máximo que nginx espera entre dois chunks do cliente.
    # Para uploads lentos (internet lenta), precisa ser generoso.
    # 30 minutos = suporta conexões de até ~230 Kbps para 512MB.
    client_body_timeout 1800s;

    # Buffer inicial em memória antes de ir para disco.
    # Arquivos maiores que isso vão para client_body_temp_path.
    client_body_buffer_size 1m;

    # Diretório temporário para bufferizar bodies grandes.
    # Os subdiretórios (1 2) distribuem os arquivos temp.
    client_body_temp_path /tmp/nginx-uploads 1 2;

    # ================================================
    # PROXY - CONEXÃO COM BACKEND (Tomcat)
    # ================================================
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;

    # Timeout para estabelecer conexão com backend (rede interna = rápido)
    proxy_connect_timeout 10s;

    # Timeout para enviar o body ao backend (já bufferizado, rede interna)
    proxy_send_timeout 300s;

    # Timeout para esperar resposta do backend.
    # Deve cobrir o tempo de upload S3 + processamento.
    proxy_read_timeout 300s;

    # ================================================
    # RESPONSE BUFFERING
    # ================================================
    proxy_buffering on;
    proxy_buffer_size 8k;
    proxy_buffers 16 32k;
    proxy_busy_buffers_size 64k;

    # ================================================
    # GZIP COMPRESSION (respostas)
    # ================================================
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 4;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/javascript
        application/json
        application/javascript
        application/xml
        application/xml+rss;

    # ================================================
    # KEEPALIVE
    # ================================================
    keepalive_timeout 65;
    keepalive_requests 1000;

    # ================================================
    # LOCATIONS
    # ================================================

    # Endpoint de health do nginx (para Docker healthcheck)
    location = /nginx-health {
        access_log off;
        return 200 'OK';
        add_header Content-Type text/plain;
    }

    # Todas as requisições vão para o backend
    location / {
        proxy_pass http://backend;
    }
}
